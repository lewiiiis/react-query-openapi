{"version":3,"file":"restful-react.esm.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Context.tsx","../src/util/composeUrl.ts","../src/util/processResponse.ts","../src/util/resolveData.ts","../src/util/constructUrl.tsx","../src/Get.tsx","../src/Poll.tsx","../src/Mutate.tsx","../src/util/useDeepCompareEffect.ts","../src/useAbort.ts","../src/useGet.tsx","../src/useMutate.tsx"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import noop from \"lodash/noop\";\nimport * as React from \"react\";\nimport { IStringifyOptions } from \"qs\";\nimport { ResolveFunction } from \"./Get\";\n\nexport interface RestfulReactProviderProps<TData = any> {\n  /** The backend URL where the RESTful resources live. */\n  base: string;\n  /**\n   * The path that gets accumulated from each level of nesting\n   * taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: ResolveFunction<TData>;\n  /**\n   * Options passed to the fetch request.\n   */\n  requestOptions?:\n    | (<TRequestBody>(\n        url: string,\n        method: string,\n        requestBody?: TRequestBody,\n      ) => Partial<RequestInit> | Promise<Partial<RequestInit>>)\n    | Partial<RequestInit>;\n  /**\n   * Trigger on each error.\n   * For `Get` and `Mutation` calls, you can also call `retry` to retry the exact same request.\n   * Please note that it's quite hard to retrieve the response data after a retry mutation in this case.\n   * Depending of your case, it can be easier to add a `localErrorOnly` on your `Mutate` component\n   * to deal with your retry locally instead of in the provider scope.\n   */\n  onError?: (\n    err: {\n      message: string;\n      data: TData | string;\n      status?: number;\n    },\n    retry: () => Promise<TData | null>,\n    response?: Response,\n  ) => void;\n  /**\n   * Trigger on each request\n   */\n  onRequest?: (req: Request) => void;\n  /**\n   * Trigger on each response\n   */\n  onResponse?: (res: Response) => void;\n  /**\n   * Any global level query params?\n   * **Warning:** it's probably not a good idea to put API keys here. Consider headers instead.\n   */\n  queryParams?: { [key: string]: any };\n  /**\n   * Query parameter stringify options applied for each request.\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n}\n\nexport const Context = React.createContext<Required<RestfulReactProviderProps>>({\n  base: \"\",\n  parentPath: \"\",\n  resolve: (data: any) => data,\n  requestOptions: {},\n  onError: noop,\n  onRequest: noop,\n  onResponse: noop,\n  queryParams: {},\n  queryParamStringifyOptions: {},\n});\n\nexport interface InjectedProps {\n  onError: RestfulReactProviderProps[\"onError\"];\n  onRequest: RestfulReactProviderProps[\"onRequest\"];\n  onResponse: RestfulReactProviderProps[\"onResponse\"];\n}\n\nexport default class RestfulReactProvider<T> extends React.Component<RestfulReactProviderProps<T>> {\n  public static displayName = \"RestfulProviderContext\";\n\n  public render() {\n    const { children, ...value } = this.props;\n    return (\n      <Context.Provider\n        value={{\n          onError: noop,\n          onRequest: noop,\n          onResponse: noop,\n          resolve: (data: any) => data,\n          requestOptions: {},\n          parentPath: \"\",\n          queryParams: {},\n          queryParamStringifyOptions: {},\n          ...value,\n        }}\n      >\n        {children}\n      </Context.Provider>\n    );\n  }\n}\n\nexport const RestfulReactConsumer = Context.Consumer;\n","import url from \"url\";\n\nexport const composeUrl = (base: string = \"\", parentPath: string = \"\", path: string = \"\"): string => {\n  const composedPath = composePath(parentPath, path);\n  /* If the base is empty, preceding slash will be trimmed during composition */\n  if (base === \"\" && composedPath.startsWith(\"/\")) {\n    return composedPath;\n  }\n\n  /* If the base contains a trailing slash, it will be trimmed during composition */\n  return base!.endsWith(\"/\") ? `${base!.slice(0, -1)}${composedPath}` : `${base}${composedPath}`;\n};\n\n/**\n * If the path starts with slash, it is considered as absolute url.\n * If not, it is considered as relative url.\n * For example,\n * parentPath = \"/someBasePath\" and path = \"/absolute\" resolves to \"/absolute\"\n * whereas,\n * parentPath = \"/someBasePath\" and path = \"relative\" resolves to \"/someBasePath/relative\"\n */\nexport const composePath = (parentPath: string = \"\", path: string = \"\"): string => {\n  if (path.startsWith(\"/\") && path.length > 1) {\n    return url.resolve(parentPath, path);\n  } else if (path !== \"\" && path !== \"/\") {\n    return `${parentPath}/${path}`;\n  } else {\n    return parentPath;\n  }\n};\n","export const processResponse = async (response: Response) => {\n  if (response.status === 204) {\n    return { data: undefined, responseError: false };\n  }\n  if ((response.headers.get(\"content-type\") || \"\").includes(\"application/json\")) {\n    try {\n      return {\n        data: await response.json(),\n        responseError: false,\n      };\n    } catch (e) {\n      return {\n        data: e.message,\n        responseError: true,\n      };\n    }\n  } else if (\n    (response.headers.get(\"content-type\") || \"\").includes(\"text/plain\") ||\n    (response.headers.get(\"content-type\") || \"\").includes(\"text/html\")\n  ) {\n    try {\n      return {\n        data: await response.text(),\n        responseError: false,\n      };\n    } catch (e) {\n      return {\n        data: e.message,\n        responseError: true,\n      };\n    }\n  } else {\n    return {\n      data: response,\n      responseError: false,\n    };\n  }\n};\n","import { GetDataError, ResolveFunction } from \"../types\";\n\nexport const resolveData = async <TData, TError>({\n  data,\n  resolve,\n}: {\n  data: any;\n  resolve?: ResolveFunction<TData>;\n}): Promise<{ data: TData | null; error: GetDataError<TError> | null }> => {\n  let resolvedData: TData | null = null;\n  let resolveError: GetDataError<TError> | null = null;\n  try {\n    if (resolve) {\n      const resolvedDataOrPromise: TData | Promise<TData> = resolve(data);\n      resolvedData = (resolvedDataOrPromise as { then?: any }).then\n        ? ((await resolvedDataOrPromise) as TData)\n        : (resolvedDataOrPromise as TData);\n    } else {\n      resolvedData = data;\n    }\n  } catch (err) {\n    resolvedData = null;\n    resolveError = {\n      message: \"RESOLVE_ERROR\",\n      data: JSON.stringify(err),\n    };\n  }\n  return {\n    data: resolvedData,\n    error: resolveError,\n  };\n};\n","import qs, { IStringifyOptions } from \"qs\";\nimport url from \"url\";\n\ntype ResolvePathOptions = {\n  queryParamOptions?: IStringifyOptions;\n  stripTrailingSlash?: boolean;\n};\n\nexport function constructUrl<TQueryParams>(\n  base: string,\n  path: string,\n  queryParams?: TQueryParams,\n  resolvePathOptions: ResolvePathOptions = {},\n) {\n  const { queryParamOptions, stripTrailingSlash } = resolvePathOptions;\n\n  const normalizedBase = base.endsWith(\"/\") ? base : `${base}/`;\n  const trimmedPath = path.startsWith(\"/\") ? path.slice(1) : path;\n\n  const encodedPathWithParams = Object.keys(queryParams || {}).length\n    ? `${trimmedPath}?${qs.stringify(queryParams, queryParamOptions)}`\n    : trimmedPath;\n\n  const composed = Boolean(encodedPathWithParams) ? url.resolve(normalizedBase, encodedPathWithParams) : normalizedBase;\n\n  return stripTrailingSlash && composed.endsWith(\"/\") ? composed.slice(0, -1) : composed;\n}\n","import { DebounceSettings } from \"lodash\";\nimport debounce from \"lodash/debounce\";\nimport isEqual from \"lodash/isEqual\";\nimport * as React from \"react\";\n\nimport RestfulReactProvider, { InjectedProps, RestfulReactConsumer, RestfulReactProviderProps } from \"./Context\";\nimport { composePath, composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\nimport { resolveData } from \"./util/resolveData\";\nimport { constructUrl } from \"./util/constructUrl\";\nimport { IStringifyOptions } from \"qs\";\n\n/**\n * A function that resolves returned data from\n * a fetch call.\n */\nexport type ResolveFunction<TData> = (data: any) => TData;\n\nexport interface GetDataError<TError> {\n  message: string;\n  data: TError | string;\n  status?: number;\n}\n\n/**\n * An enumeration of states that a fetchable\n * view could possibly have.\n */\nexport interface States<TData, TError> {\n  /** Is our view currently loading? */\n  loading: boolean;\n  /** Do we have an error in the view? */\n  error?: GetState<TData, TError>[\"error\"];\n}\n\nexport type GetMethod<TData> = () => Promise<TData | null>;\n\n/**\n * An interface of actions that can be performed\n * within Get\n */\nexport interface Actions<TData> {\n  /** Refetches the same path */\n  refetch: GetMethod<TData>;\n}\n\n/**\n * Meta information returned to the fetchable\n * view.\n */\nexport interface Meta {\n  /** The entire response object passed back from the request. */\n  response: Response | null;\n  /** The absolute path of this request. */\n  absolutePath: string;\n}\n\n/**\n * Props for the <Get /> component.\n */\nexport interface GetProps<TData, TError, TQueryParams, TPathParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parent Gets or the RestfulProvider.\n   */\n  path: string;\n  /**\n   * @private This is an internal implementation detail in restful-react, not meant to be used externally.\n   * This helps restful-react correctly override `path`s when a new `base` property is provided.\n   */\n  __internal_hasExplicitBase?: boolean;\n  /**\n   * A function that recieves the returned, resolved\n   * data.\n   *\n   * @param data - data returned from the request.\n   * @param actions - a key/value map of HTTP verbs, aliasing destroy to DELETE.\n   */\n  children: (data: TData | null, states: States<TData, TError>, actions: Actions<TData>, meta: Meta) => React.ReactNode;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Path parameters\n   */\n  pathParams?: TPathParams;\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Query parameter stringify options\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: ResolveFunction<TData>;\n  /**\n   * Should we wait until we have data before rendering?\n   * This is useful in cases where data is available too quickly\n   * to display a spinner or some type of loading state.\n   */\n  wait?: boolean;\n  /**\n   * Should we fetch data at a later stage?\n   */\n  lazy?: boolean;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * The accumulated path from each level of parent GETs\n   *  taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /**\n   * How long do we wait between subsequent requests?\n   * Uses [lodash's debounce](https://lodash.com/docs/4.17.10#debounce) under the hood.\n   */\n  debounce?:\n    | {\n        wait?: number;\n        options: DebounceSettings;\n      }\n    | boolean\n    | number;\n}\n\n/**\n * State for the <Get /> component. These\n * are implementation details and should be\n * hidden from any consumers.\n */\nexport interface GetState<TData, TError> {\n  data: TData | null;\n  response: Response | null;\n  error: GetDataError<TError> | null;\n  loading: boolean;\n}\n\n/**\n * The <Get /> component without Context. This\n * is a named class because it is useful in\n * debugging.\n */\nclass ContextlessGet<TData, TError, TQueryParams, TPathParams = unknown> extends React.Component<\n  GetProps<TData, TError, TQueryParams, TPathParams> & InjectedProps,\n  Readonly<GetState<TData, TError>>\n> {\n  constructor(props: GetProps<TData, TError, TQueryParams, TPathParams> & InjectedProps) {\n    super(props);\n\n    if (typeof props.debounce === \"object\") {\n      this.fetch = debounce(this.fetch, props.debounce.wait, props.debounce.options);\n    } else if (typeof props.debounce === \"number\") {\n      this.fetch = debounce(this.fetch, props.debounce);\n    } else if (props.debounce) {\n      this.fetch = debounce(this.fetch);\n    }\n  }\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  public readonly state: Readonly<GetState<TData, TError>> = {\n    data: null, // Means we don't _yet_ have data.\n    response: null,\n    loading: !this.props.lazy,\n    error: null,\n  };\n\n  public static defaultProps = {\n    base: \"\",\n    parentPath: \"\",\n    resolve: (unresolvedData: any) => unresolvedData,\n    queryParams: {},\n  };\n\n  public componentDidMount() {\n    if (!this.props.lazy) {\n      this.fetch();\n    }\n  }\n\n  public componentDidUpdate(prevProps: GetProps<TData, TError, TQueryParams, TPathParams>) {\n    const { base, parentPath, path, resolve, queryParams, requestOptions } = prevProps;\n    if (\n      base !== this.props.base ||\n      parentPath !== this.props.parentPath ||\n      path !== this.props.path ||\n      !isEqual(queryParams, this.props.queryParams) ||\n      // both `resolve` props need to _exist_ first, and then be equivalent.\n      (resolve && this.props.resolve && resolve.toString() !== this.props.resolve.toString()) ||\n      (requestOptions &&\n        this.props.requestOptions &&\n        requestOptions.toString() !== this.props.requestOptions.toString())\n    ) {\n      if (!this.props.lazy) {\n        this.fetch();\n      }\n    }\n  }\n\n  public componentWillUnmount() {\n    this.abortController.abort();\n  }\n\n  public getRequestOptions = async (\n    url: string,\n    extraOptions?: Partial<RequestInit>,\n    extraHeaders?: boolean | { [key: string]: string },\n  ) => {\n    const { requestOptions } = this.props;\n\n    if (typeof requestOptions === \"function\") {\n      const options = (await requestOptions(url, \"GET\")) || {};\n      return {\n        ...extraOptions,\n        ...options,\n        headers: new Headers({\n          ...(typeof extraHeaders !== \"boolean\" ? extraHeaders : {}),\n          ...(extraOptions || {}).headers,\n          ...options.headers,\n        }),\n      };\n    }\n\n    return {\n      ...extraOptions,\n      ...requestOptions,\n      headers: new Headers({\n        ...(typeof extraHeaders !== \"boolean\" ? extraHeaders : {}),\n        ...(extraOptions || {}).headers,\n        ...(requestOptions || {}).headers,\n      }),\n    };\n  };\n\n  public fetch = async (requestPath?: string, thisRequestOptions?: RequestInit) => {\n    const { base, __internal_hasExplicitBase, parentPath, path, resolve, onError, onRequest, onResponse } = this.props;\n\n    if (this.state.error || !this.state.loading) {\n      this.setState(() => ({ error: null, loading: true }));\n    }\n\n    const makeRequestPath = () => {\n      const concatPath = __internal_hasExplicitBase ? path : composePath(parentPath, path);\n\n      return constructUrl(base!, concatPath, this.props.queryParams, {\n        stripTrailingSlash: true,\n        queryParamOptions: this.props.queryParamStringifyOptions,\n      });\n    };\n\n    const request = new Request(makeRequestPath(), await this.getRequestOptions(makeRequestPath(), thisRequestOptions));\n    if (onRequest) onRequest(request);\n    try {\n      const response = await fetch(request, { signal: this.signal });\n      const originalResponse = response.clone();\n      if (onResponse) onResponse(response.clone());\n      const { data, responseError } = await processResponse(response);\n\n      // avoid state updates when component has been unmounted\n      if (this.signal.aborted) {\n        return;\n      }\n\n      if (!response.ok || responseError) {\n        const error = {\n          message: `Failed to fetch: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n          data,\n          status: response.status,\n        };\n\n        this.setState({\n          loading: false,\n          error,\n          data: null,\n          response: originalResponse,\n        });\n\n        if (!this.props.localErrorOnly && onError) {\n          onError(error, () => this.fetch(requestPath, thisRequestOptions), response);\n        }\n\n        return null;\n      }\n\n      const resolved = await resolveData<TData, TError>({ data, resolve });\n\n      this.setState({ loading: false, data: resolved.data, error: resolved.error, response: originalResponse });\n      return data;\n    } catch (e) {\n      // avoid state updates when component has been unmounted\n      // and when fetch/processResponse threw an error\n      if (this.signal.aborted) {\n        return;\n      }\n\n      this.setState({\n        loading: false,\n        data: null,\n        error: {\n          message: `Failed to fetch: ${e.message}`,\n          data: e,\n        },\n      });\n    }\n  };\n\n  public render() {\n    const { children, wait, path, base, parentPath } = this.props;\n    const { data, error, loading, response } = this.state;\n\n    if (wait && data === null && !error) {\n      return <></>; // Show nothing until we have data.\n    }\n\n    return children(\n      data,\n      { loading, error },\n      { refetch: this.fetch },\n      { response, absolutePath: composeUrl(base!, parentPath!, path) },\n    );\n  }\n}\n\n/**\n * The <Get /> component _with_ context.\n * Context is used to compose path props,\n * and to maintain the base property against\n * which all requests will be made.\n *\n * We compose Consumers immediately with providers\n * in order to provide new `parentPath` props that contain\n * a segment of the path, creating composable URLs.\n */\nfunction Get<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  props: GetProps<TData, TError, TQueryParams, TPathParams>,\n) {\n  return (\n    <RestfulReactConsumer>\n      {contextProps => (\n        <RestfulReactProvider {...contextProps} parentPath={composePath(contextProps.parentPath, props.path)}>\n          <ContextlessGet\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams }}\n            __internal_hasExplicitBase={Boolean(props.base)}\n            queryParamStringifyOptions={{\n              ...contextProps.queryParamStringifyOptions,\n              ...props.queryParamStringifyOptions,\n            }}\n          />\n        </RestfulReactProvider>\n      )}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Get;\n","import merge from \"lodash/merge\";\nimport * as React from \"react\";\nimport equal from \"react-fast-compare\";\n\nimport { InjectedProps, RestfulReactConsumer } from \"./Context\";\nimport { GetProps, GetState, Meta as GetComponentMeta } from \"./Get\";\nimport { composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\nimport { constructUrl } from \"./util/constructUrl\";\nimport { IStringifyOptions } from \"qs\";\n\n/**\n * Meta information returned from the poll.\n */\ninterface Meta extends GetComponentMeta {\n  /**\n   * The entire response object.\n   */\n  response: Response | null;\n}\n\n/**\n * States of the current poll\n */\ninterface States<TData, TError> {\n  /**\n   * Is the component currently polling?\n   */\n  polling: PollState<TData, TError>[\"polling\"];\n  /**\n   * Is the initial request loading?\n   */\n  loading: PollState<TData, TError>[\"loading\"];\n  /**\n   * Has the poll concluded?\n   */\n  finished: PollState<TData, TError>[\"finished\"];\n  /**\n   * Is there an error? What is it?\n   */\n  error: PollState<TData, TError>[\"error\"];\n}\n\n/**\n * Actions that can be executed within the\n * component.\n */\ninterface Actions {\n  start: () => void;\n  stop: () => void;\n}\n\n/**\n * Props that can control the Poll component.\n */\nexport interface PollProps<TData, TError, TQueryParams, TPathParams> {\n  /**\n   * What path are we polling on?\n   */\n  path: GetProps<TData, TError, TQueryParams, TPathParams>[\"path\"];\n  /**\n   * A function that gets polled data, the current\n   * states, meta information, and various actions\n   * that can be executed at the poll-level.\n   */\n  children: (data: TData | null, states: States<TData, TError>, actions: Actions, meta: Meta) => React.ReactNode;\n  /**\n   * How long do we wait between repeating a request?\n   * Value in milliseconds.\n   *\n   * Defaults to 1000.\n   */\n  interval?: number;\n  /**\n   * How long should a request stay open?\n   * Value in seconds.\n   *\n   * Defaults to 60.\n   */\n  wait?: number;\n  /**\n   * A stop condition for the poll that expects\n   * a boolean.\n   *\n   * @param data - The data returned from the poll.\n   * @param response - The full response object. This could be useful in order to stop polling when !response.ok, for example.\n   */\n  until?: (data: TData | null, response: Response | null) => boolean;\n  /**\n   * Are we going to wait to start the poll?\n   * Use this with { start, stop } actions.\n   */\n  lazy?: GetProps<TData, TError, TQueryParams, TPathParams>[\"lazy\"];\n  /**\n   * Should the data be transformed in any way?\n   */\n  resolve?: (data: any, prevData: TData | null) => TData;\n  /**\n   * We can request foreign URLs with this prop.\n   */\n  base?: GetProps<TData, TError, TQueryParams, TPathParams>[\"base\"];\n  /**\n   * Any options to be passed to this request.\n   */\n  requestOptions?: GetProps<TData, TError, TQueryParams, TPathParams>[\"requestOptions\"];\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Query parameter stringify options\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n}\n\n/**\n * The state of the Poll component. This should contain\n * implementation details not necessarily exposed to\n * consumers.\n */\nexport interface PollState<TData, TError> {\n  /**\n   * Are we currently polling?\n   */\n  polling: boolean;\n  /**\n   * Have we finished polling?\n   */\n  finished: boolean;\n  /**\n   * What was the last response?\n   */\n  lastResponse: Response | null;\n  /**\n   * What data are we holding in here?\n   */\n  data: GetState<TData, TError>[\"data\"];\n  /**\n   * What data did we had before?\n   */\n  previousData: GetState<TData, TError>[\"data\"];\n  /**\n   * Are we loading?\n   */\n  loading: GetState<TData, TError>[\"loading\"];\n  /**\n   * Do we currently have an error?\n   */\n  error: GetState<TData, TError>[\"error\"];\n  /**\n   * Index of the last polled response.\n   */\n  lastPollIndex?: string;\n}\n\n/**\n * The <Poll /> component without context.\n */\nclass ContextlessPoll<TData, TError, TQueryParams, TPathParams = unknown> extends React.Component<\n  PollProps<TData, TError, TQueryParams, TPathParams> & InjectedProps,\n  Readonly<PollState<TData, TError>>\n> {\n  public readonly state: Readonly<PollState<TData, TError>> = {\n    data: null,\n    previousData: null,\n    loading: !this.props.lazy,\n    lastResponse: null,\n    polling: !this.props.lazy,\n    finished: false,\n    error: null,\n  };\n\n  public static defaultProps = {\n    interval: 1000,\n    wait: 60,\n    base: \"\",\n    resolve: (data: any) => data,\n    queryParams: {},\n  };\n\n  private keepPolling = !this.props.lazy;\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  private isModified = (response: Response, nextData: TData) => {\n    if (response.status === 304) {\n      return false;\n    }\n    if (equal(this.state.data, nextData)) {\n      return false;\n    }\n    return true;\n  };\n\n  private getRequestOptions = (url: string) =>\n    typeof this.props.requestOptions === \"function\"\n      ? this.props.requestOptions(url, \"GET\")\n      : this.props.requestOptions || {};\n\n  // 304 is not a OK status code but is green in Chrome 🤦🏾‍♂️\n  private isResponseOk = (response: Response) => response.ok || response.status === 304;\n\n  /**\n   * This thing does the actual poll.\n   */\n  public cycle = async () => {\n    // Have we stopped?\n    if (!this.keepPolling) {\n      return; // stop.\n    }\n\n    // Should we stop?\n    if (this.props.until && this.props.until(this.state.data, this.state.lastResponse)) {\n      this.stop(); // stop.\n      return;\n    }\n\n    // If we should keep going,\n    const { base, path, interval, wait, onError, onRequest, onResponse } = this.props;\n    const { lastPollIndex } = this.state;\n\n    const url = constructUrl(base!, path, this.props.queryParams, {\n      queryParamOptions: this.props.queryParamStringifyOptions,\n      stripTrailingSlash: true,\n    });\n\n    const requestOptions = await this.getRequestOptions(url);\n\n    const request = new Request(url, {\n      ...requestOptions,\n      headers: {\n        Prefer: `wait=${wait}s;${lastPollIndex ? `index=${lastPollIndex}` : \"\"}`,\n        ...requestOptions.headers,\n      },\n    });\n    if (onRequest) onRequest(request);\n\n    try {\n      const response = await fetch(request, { signal: this.signal });\n      if (onResponse) onResponse(response.clone());\n      const { data, responseError } = await processResponse(response);\n\n      if (!this.keepPolling || this.signal.aborted) {\n        // Early return if we have stopped polling or component was unmounted\n        // to avoid memory leaks\n        return;\n      }\n\n      if (!this.isResponseOk(response) || responseError) {\n        const error = {\n          message: `Failed to poll: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n          data,\n          status: response.status,\n        };\n        this.setState({ loading: false, lastResponse: response, error });\n\n        if (!this.props.localErrorOnly && onError) {\n          onError(error, () => Promise.resolve(), response);\n        }\n      } else if (this.isModified(response, data)) {\n        this.setState(prevState => ({\n          loading: false,\n          lastResponse: response,\n          previousData: prevState.data,\n          data,\n          error: null,\n          lastPollIndex: response.headers.get(\"x-polling-index\") || undefined,\n        }));\n      }\n\n      // Wait for interval to pass.\n      await new Promise(resolvePromise => setTimeout(resolvePromise, interval));\n      this.cycle(); // Do it all again!\n    } catch (e) {\n      // the only error not catched is the `fetch`, this means that we have cancelled the fetch\n    }\n  };\n\n  public start = () => {\n    this.keepPolling = true;\n    if (!this.state.polling) {\n      this.setState(() => ({ polling: true })); // let everyone know we're done here.\n    }\n    this.cycle();\n  };\n\n  public stop = () => {\n    this.keepPolling = false;\n    this.setState(() => ({ polling: false, finished: true })); // let everyone know we're done here.\n  };\n\n  public componentDidMount() {\n    const { path, lazy } = this.props;\n\n    if (path === undefined) {\n      throw new Error(\n        `[restful-react]: You're trying to poll something without a path. Please specify a \"path\" prop on your Poll component.`,\n      );\n    }\n\n    if (!lazy) {\n      this.start();\n    }\n  }\n\n  public componentWillUnmount() {\n    // Cancel the current query\n    this.abortController.abort();\n\n    // Stop the polling cycle\n    this.stop();\n  }\n\n  public render() {\n    const { lastResponse: response, previousData, data, polling, loading, error, finished } = this.state;\n    const { children, base, path, resolve } = this.props;\n\n    const meta: Meta = {\n      response,\n      absolutePath: composeUrl(base!, \"\", path),\n    };\n\n    const states: States<TData, TError> = {\n      polling,\n      loading,\n      error,\n      finished,\n    };\n\n    const actions: Actions = {\n      stop: this.stop,\n      start: this.start,\n    };\n    // data is parsed only when poll has already resolved so response is defined\n    const resolvedData = response && resolve ? resolve(data, previousData) : data;\n    return children(resolvedData, states, actions, meta);\n  }\n}\n\nfunction Poll<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  props: PollProps<TData, TError, TQueryParams, TPathParams>,\n) {\n  // Compose Contexts to allow for URL nesting\n  return (\n    <RestfulReactConsumer>\n      {contextProps => {\n        return (\n          <ContextlessPoll\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams }}\n            requestOptions={async (url: string, method: string) => {\n              const contextRequestOptions =\n                typeof contextProps.requestOptions === \"function\"\n                  ? await contextProps.requestOptions(url, method)\n                  : contextProps.requestOptions || {};\n              const propsRequestOptions =\n                typeof props.requestOptions === \"function\"\n                  ? await props.requestOptions(url, method)\n                  : props.requestOptions || {};\n\n              return merge(contextRequestOptions, propsRequestOptions);\n            }}\n            queryParamStringifyOptions={{\n              ...contextProps.queryParamStringifyOptions,\n              ...props.queryParamStringifyOptions,\n            }}\n          />\n        );\n      }}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Poll;\n","import * as React from \"react\";\nimport RestfulReactProvider, { InjectedProps, RestfulReactConsumer, RestfulReactProviderProps } from \"./Context\";\nimport { GetState, ResolveFunction } from \"./Get\";\nimport { composePath, composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\nimport { constructUrl } from \"./util/constructUrl\";\nimport { IStringifyOptions } from \"qs\";\n\n/**\n * An enumeration of states that a fetchable\n * view could possibly have.\n */\nexport interface States<TData, TError> {\n  /** Is our view currently loading? */\n  loading: boolean;\n  /** Do we have an error in the view? */\n  error?: GetState<TData, TError>[\"error\"];\n}\n\nexport interface MutateRequestOptions<TQueryParams, TPathParams> extends RequestInit {\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Path parameters\n   */\n  pathParams?: TPathParams;\n}\n\nexport type MutateMethod<TData, TRequestBody, TQueryParams, TPathParams> = (\n  data: TRequestBody,\n  mutateRequestOptions?: MutateRequestOptions<TQueryParams, TPathParams>,\n) => Promise<TData>;\n\n/**\n * Meta information returned to the fetchable\n * view.\n */\nexport interface Meta {\n  /** The absolute path of this request. */\n  absolutePath: string;\n}\n\n/**\n * Props for the <Mutate /> component.\n */\nexport interface MutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parents or the RestfulProvider.\n   */\n  path?: string;\n  /**\n   * @private This is an internal implementation detail in restful-react, not meant to be used externally.\n   * This helps restful-react correctly override `path`s when a new `base` property is provided.\n   */\n  __internal_hasExplicitBase?: boolean;\n  /**\n   * What HTTP verb are we using?\n   */\n  verb: \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Query parameter stringify options\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * The accumulated path from each level of parent GETs\n   *  taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function that recieves a mutation function, along with\n   * some metadata.\n   *\n   * @param actions - a key/value map of HTTP verbs, aliasing destroy to DELETE.\n   */\n  children: (\n    mutate: MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>,\n    states: States<TData, TError>,\n    meta: Meta,\n  ) => React.ReactNode;\n  /**\n   * Callback called after the mutation is done.\n   *\n   * @param body - Body given to mutate\n   * @param data - Response data\n   */\n  onMutate?: (body: TRequestBody, data: TData) => void;\n  /**\n   * A function to encode body of DELETE requests when appending it\n   * to an existing path\n   */\n  pathInlineBodyEncode?: typeof encodeURIComponent;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: ResolveFunction<TData>;\n}\n\n/**\n * State for the <Mutate /> component. These\n * are implementation details and should be\n * hidden from any consumers.\n */\nexport interface MutateState<TData, TError> {\n  error: GetState<TData, TError>[\"error\"];\n  loading: boolean;\n}\n\n/**\n * The <Mutate /> component without Context. This\n * is a named class because it is useful in\n * debugging.\n */\nclass ContextlessMutate<TData, TError, TQueryParams, TRequestBody, TPathParams> extends React.Component<\n  MutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams> & InjectedProps,\n  MutateState<TData, TError>\n> {\n  public readonly state: Readonly<MutateState<TData, TError>> = {\n    loading: false,\n    error: null,\n  };\n\n  public static defaultProps = {\n    base: \"\",\n    parentPath: \"\",\n    path: \"\",\n    queryParams: {},\n  };\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  public componentWillUnmount() {\n    this.abortController.abort();\n  }\n\n  public mutate = async (\n    body: TRequestBody,\n    mutateRequestOptions?: MutateRequestOptions<TQueryParams, TPathParams>,\n  ) => {\n    const {\n      __internal_hasExplicitBase,\n      base,\n      parentPath,\n      path,\n      verb,\n      requestOptions: providerRequestOptions,\n      onError,\n      onRequest,\n      onResponse,\n      pathInlineBodyEncode,\n      resolve,\n    } = this.props;\n    this.setState(() => ({ error: null, loading: true }));\n\n    const makeRequestPath = () => {\n      const pathWithPossibleBody =\n        verb === \"DELETE\" && typeof body === \"string\"\n          ? composePath(path, pathInlineBodyEncode ? pathInlineBodyEncode(body) : body)\n          : path;\n\n      const concatPath = __internal_hasExplicitBase\n        ? pathWithPossibleBody || \"\"\n        : composePath(parentPath, pathWithPossibleBody);\n\n      return constructUrl(base!, concatPath, this.props.queryParams, {\n        stripTrailingSlash: true,\n        queryParamOptions: this.props.queryParamStringifyOptions,\n      });\n    };\n\n    const request = new Request(makeRequestPath(), {\n      method: verb,\n      body: body instanceof FormData ? body : typeof body === \"object\" ? JSON.stringify(body) : body,\n      ...(typeof providerRequestOptions === \"function\"\n        ? await providerRequestOptions<TRequestBody>(makeRequestPath(), verb, body)\n        : providerRequestOptions),\n      ...mutateRequestOptions,\n      headers: {\n        ...(typeof providerRequestOptions === \"function\"\n          ? (await providerRequestOptions<TRequestBody>(makeRequestPath(), verb, body)).headers\n          : (providerRequestOptions || {}).headers),\n        ...(mutateRequestOptions ? mutateRequestOptions.headers : {}),\n      },\n    } as RequestInit); // Type assertion for version of TypeScript that can't yet discriminate.\n\n    // only set default content-type if body is not of type FormData and there is no content-type already defined on mutateRequestOptions.headers\n    if (!(body instanceof FormData) && !request.headers.has(\"content-type\")) {\n      request.headers.set(\"content-type\", typeof body === \"object\" ? \"application/json\" : \"text/plain\");\n    }\n\n    if (onRequest) onRequest(request);\n\n    let response: Response;\n    try {\n      response = await fetch(request, { signal: this.signal });\n      if (onResponse) onResponse(response.clone());\n    } catch (e) {\n      const error = {\n        message: `Failed to fetch: ${e.message}`,\n        data: \"\",\n      };\n\n      this.setState({\n        error,\n        loading: false,\n      });\n\n      if (!this.props.localErrorOnly && onError) {\n        onError(error, () => this.mutate(body, mutateRequestOptions));\n      }\n\n      throw error;\n    }\n\n    const { data: rawData, responseError } = await processResponse(response);\n\n    let data: TData | any; // `any` -> data in error case\n    try {\n      data = resolve ? resolve(rawData) : rawData;\n    } catch (e) {\n      if (this.signal.aborted) {\n        return;\n      }\n      const error = {\n        data: e.message,\n        message: `Failed to resolve: ${e.message}`,\n      };\n\n      this.setState({\n        error,\n        loading: false,\n      });\n      throw e;\n    }\n\n    // avoid state updates when component has been unmounted\n    if (this.signal.aborted) {\n      return;\n    }\n    if (!response.ok || responseError) {\n      const error = {\n        data,\n        message: `Failed to fetch: ${response.status} ${response.statusText}`,\n        status: response.status,\n      };\n\n      this.setState({\n        error,\n        loading: false,\n      });\n\n      if (!this.props.localErrorOnly && onError) {\n        onError(error, () => this.mutate(body, mutateRequestOptions), response);\n      }\n\n      throw error;\n    }\n\n    this.setState({ loading: false });\n\n    if (this.props.onMutate) {\n      this.props.onMutate(body, data);\n    }\n\n    return data;\n  };\n\n  public render() {\n    const { children, path, base, parentPath } = this.props;\n    const { error, loading } = this.state;\n\n    return children(this.mutate, { loading, error }, { absolutePath: composeUrl(base!, parentPath!, path!) });\n  }\n}\n\n/**\n * The <Mutate /> component _with_ context.\n * Context is used to compose path props,\n * and to maintain the base property against\n * which all requests will be made.\n *\n * We compose Consumers immediately with providers\n * in order to provide new `parentPath` props that contain\n * a segment of the path, creating composable URLs.\n */\nfunction Mutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(props: MutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>) {\n  return (\n    <RestfulReactConsumer>\n      {contextProps => (\n        <RestfulReactProvider {...contextProps} parentPath={composePath(contextProps.parentPath, props.path!)}>\n          <ContextlessMutate<TData, TError, TQueryParams, TRequestBody, TPathParams>\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams } as TQueryParams}\n            queryParamStringifyOptions={{\n              ...contextProps.queryParamStringifyOptions,\n              ...props.queryParamStringifyOptions,\n            }}\n            __internal_hasExplicitBase={Boolean(props.base)}\n          />\n        </RestfulReactProvider>\n      )}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Mutate;\n","import isEqualWith from \"lodash/isEqualWith\";\nimport React, { useCallback, useEffect, useRef } from \"react\";\n\n/**\n * Custom version of isEqual to handle function comparison\n */\nconst isEqual = (x: any, y: any) =>\n  isEqualWith(x, y, (a, b) => {\n    // Deal with the function comparison case\n    if (typeof a === \"function\" && typeof b === \"function\") {\n      return a.toString() === b.toString();\n    }\n    // Fallback on the method\n    return undefined;\n  });\n\nfunction useDeepCompareMemoize(value: Readonly<any>) {\n  const ref = useRef<any>();\n\n  if (!isEqual(value, ref.current)) {\n    ref.current = value;\n  }\n\n  return ref.current;\n}\n\n/**\n * Accepts a function that contains imperative, possibly effectful code.\n *\n * This is the deepCompare version of the `React.useEffect` hooks (that is shallowed compare)\n *\n * @param effect Imperative function that can return a cleanup function\n * @param deps If present, effect will only activate if the values in the list change.\n *\n * @see https://gist.github.com/kentcdodds/fb8540a05c43faf636dd68647747b074#gistcomment-2830503\n */\nexport function useDeepCompareEffect<T>(effect: React.EffectCallback, deps: T) {\n  useEffect(effect, useDeepCompareMemoize(deps));\n}\n\nexport function useDeepCompareCallback<T extends (...args: any[]) => any>(callback: T, deps: readonly any[]) {\n  return useCallback(callback, useDeepCompareMemoize(deps));\n}\n","import { useCallback, useRef } from \"react\";\n\nfunction createAbortController() {\n  try {\n    return new AbortController();\n  } catch {\n    return undefined;\n  }\n}\n\nexport function useAbort() {\n  const instance = useRef(createAbortController());\n\n  const abort = useCallback(() => {\n    if (instance && instance.current) {\n      instance.current.abort();\n      instance.current = createAbortController();\n    }\n  }, [instance]);\n\n  return {\n    abort,\n    getAbortSignal() {\n      return instance?.current?.signal;\n    },\n  };\n}\n","import { useContext, useState, useCallback, useEffect } from \"react\";\nimport { Cancelable, DebounceSettings } from \"lodash\";\nimport debounce from \"lodash/debounce\";\nimport merge from \"lodash/merge\";\nimport { IStringifyOptions } from \"qs\";\n\nimport { Context, RestfulReactProviderProps } from \"./Context\";\nimport { GetState } from \"./Get\";\nimport { processResponse } from \"./util/processResponse\";\nimport { useDeepCompareCallback } from \"./util/useDeepCompareEffect\";\nimport { useAbort } from \"./useAbort\";\nimport { constructUrl } from \"./util/constructUrl\";\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\nexport interface UseGetProps<TData, TError, TQueryParams, TPathParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parent Gets or the RestfulProvider.\n   */\n  path: string | ((pathParams: TPathParams) => string);\n  /**\n   * Path Parameters\n   */\n  pathParams?: TPathParams;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Query parameter stringify options\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: (data: any) => TData;\n  /**\n   * Developer mode\n   * Override the state with some mocks values and avoid to fetch\n   */\n  mock?: { data?: TData; error?: TError; loading?: boolean; response?: Response };\n  /**\n   * Should we fetch data at a later stage?\n   */\n  lazy?: boolean;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * How long do we wait between subsequent requests?\n   * Uses [lodash's debounce](https://lodash.com/docs/4.17.10#debounce) under the hood.\n   */\n  debounce?:\n    | {\n        wait?: number;\n        options: DebounceSettings;\n      }\n    | boolean\n    | number;\n}\n\ntype FetchData<TData, TError, TQueryParams, PathParams = unknown> = (\n  props: UseGetProps<TData, TError, TQueryParams, PathParams>,\n  context: RestfulReactProviderProps,\n  abort: () => void,\n  getAbortSignal: () => AbortSignal | undefined,\n) => Promise<void>;\ntype CancellableFetchData<TData, TError, TQueryParams, TPathParams> =\n  | FetchData<TData, TError, TQueryParams, TPathParams>\n  | (FetchData<TData, TError, TQueryParams, TPathParams> & Cancelable);\ntype RefetchOptions<TData, TError, TQueryParams, TPathParams> = Partial<\n  Omit<UseGetProps<TData, TError, TQueryParams, TPathParams>, \"lazy\">\n>;\n\nconst isCancellable = <T extends (...args: any[]) => any>(func: T): func is T & Cancelable => {\n  return typeof (func as any).cancel === \"function\" && typeof (func as any).flush === \"function\";\n};\n\nexport interface UseGetReturn<TData, TError, TQueryParams = {}, TPathParams = unknown> extends GetState<TData, TError> {\n  /**\n   * Absolute path resolved from `base` and `path` (context & local)\n   */\n  absolutePath: string;\n  /**\n   * Cancel the current fetch\n   */\n  cancel: () => void;\n  /**\n   * Refetch\n   */\n  refetch: (options?: RefetchOptions<TData, TError, TQueryParams, TPathParams>) => Promise<TData | null>;\n}\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  path: UseGetProps<TData, TError, TQueryParams, TPathParams>[\"path\"],\n  props?: Omit<UseGetProps<TData, TError, TQueryParams, TPathParams>, \"path\">,\n): UseGetReturn<TData, TError, TQueryParams>;\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  props: UseGetProps<TData, TError, TQueryParams, TPathParams>,\n): UseGetReturn<TData, TError, TQueryParams>;\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>() {\n  const props: UseGetProps<TData, TError, TQueryParams, TPathParams> =\n    typeof arguments[0] === \"object\" ? arguments[0] : { ...arguments[1], path: arguments[0] };\n\n  const context = useContext(Context);\n  const { path, pathParams = {} } = props;\n\n  const [state, setState] = useState<GetState<TData, TError>>({\n    data: null,\n    response: null,\n    loading: !props.lazy,\n    error: null,\n  });\n\n  const { abort, getAbortSignal } = useAbort();\n\n  const pathStr = typeof path === \"function\" ? path(pathParams as TPathParams) : path;\n\n  const _fetchData = useDeepCompareCallback<FetchData<TData, TError, TQueryParams, TPathParams>>(\n    async (props, context, abort, getAbortSignal) => {\n      const {\n        base = context.base,\n        path,\n        resolve = context.resolve || ((d: any) => d as TData),\n        queryParams = {},\n        queryParamStringifyOptions = {},\n        requestOptions,\n        pathParams = {},\n      } = props;\n\n      setState(prev => {\n        if (prev.error || !prev.loading) {\n          return { ...prev, error: null, loading: true };\n        }\n        return prev;\n      });\n\n      const pathStr = typeof path === \"function\" ? path(pathParams as TPathParams) : path;\n\n      const url = constructUrl(\n        base,\n        pathStr,\n        { ...context.queryParams, ...queryParams },\n        {\n          queryParamOptions: { ...context.queryParamStringifyOptions, ...queryParamStringifyOptions },\n        },\n      );\n\n      const propsRequestOptions =\n        (typeof requestOptions === \"function\" ? await requestOptions(url, \"GET\") : requestOptions) || {};\n\n      const contextRequestOptions =\n        (typeof context.requestOptions === \"function\"\n          ? await context.requestOptions(url, \"GET\")\n          : context.requestOptions) || {};\n\n      const signal = getAbortSignal();\n\n      const request = new Request(url, merge({}, contextRequestOptions, propsRequestOptions, { signal }));\n      if (context.onRequest) context.onRequest(request);\n\n      try {\n        const response = await fetch(request);\n        const originalResponse = response.clone();\n        if (context.onResponse) context.onResponse(originalResponse);\n        const { data, responseError } = await processResponse(response);\n\n        if (signal && signal.aborted) {\n          return;\n        }\n\n        if (!response.ok || responseError) {\n          const error = {\n            message: `Failed to fetch: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n            data,\n            status: response.status,\n          };\n\n          setState(prev => ({\n            ...prev,\n            loading: false,\n            data: null,\n            error,\n            response: originalResponse,\n          }));\n\n          if (!props.localErrorOnly && context.onError) {\n            context.onError(error, () => _fetchData(props, context, abort, getAbortSignal), response);\n          }\n          return;\n        }\n\n        const resolvedData = resolve(data);\n        setState(prev => ({\n          ...prev,\n          error: null,\n          loading: false,\n          data: resolvedData,\n          response: originalResponse,\n        }));\n        return resolvedData;\n      } catch (e) {\n        // avoid state updates when component has been unmounted\n        // and when fetch/processResponse threw an error\n        if (signal && signal.aborted) {\n          return;\n        }\n\n        const error = {\n          message: `Failed to fetch: ${e.message}`,\n          data: e.message,\n        };\n\n        setState(prev => ({\n          ...prev,\n          data: null,\n          loading: false,\n          error,\n        }));\n\n        if (!props.localErrorOnly && context.onError) {\n          context.onError(error, () => _fetchData(props, context, abort, getAbortSignal));\n        }\n\n        return;\n      }\n    },\n    [\n      props.lazy,\n      props.mock,\n      props.path,\n      props.base,\n      props.resolve,\n      props.queryParams,\n      props.requestOptions,\n      props.pathParams,\n      context.base,\n      context.parentPath,\n      context.queryParams,\n      context.requestOptions,\n      abort,\n    ],\n  );\n  const fetchData = useCallback<CancellableFetchData<TData, TError, TQueryParams, TPathParams>>(\n    typeof props.debounce === \"object\"\n      ? debounce<FetchData<TData, TError, TQueryParams, TPathParams>>(\n          _fetchData,\n          props.debounce.wait,\n          props.debounce.options,\n        )\n      : typeof props.debounce === \"number\"\n      ? debounce<FetchData<TData, TError, TQueryParams, TPathParams>>(_fetchData, props.debounce)\n      : props.debounce\n      ? debounce<FetchData<TData, TError, TQueryParams, TPathParams>>(_fetchData)\n      : _fetchData,\n    [_fetchData, props.debounce],\n  );\n\n  useEffect(() => {\n    if (!props.lazy && !props.mock) {\n      fetchData(props, context, abort, getAbortSignal);\n    }\n\n    return () => {\n      if (isCancellable(fetchData)) {\n        fetchData.cancel();\n      }\n      abort();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [fetchData, props.lazy, props.mock]);\n\n  const refetch = useCallback(\n    (options: RefetchOptions<TData, TError, TQueryParams, TPathParams> = {}) =>\n      fetchData({ ...props, ...options }, context, abort, getAbortSignal),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [fetchData],\n  );\n\n  return {\n    ...state,\n    ...props.mock, // override the state\n    absolutePath: constructUrl(\n      props.base || context.base,\n      pathStr,\n      {\n        ...context.queryParams,\n        ...props.queryParams,\n      },\n      {\n        queryParamOptions: {\n          ...context.queryParamStringifyOptions,\n          ...props.queryParamStringifyOptions,\n        },\n      },\n    ),\n    cancel: () => {\n      setState({\n        ...state,\n        loading: false,\n      });\n      abort();\n    },\n    refetch,\n  };\n}\n","import merge from \"lodash/merge\";\nimport { useContext, useEffect, useState } from \"react\";\nimport { Context } from \"./Context\";\nimport { MutateMethod, MutateState, MutateRequestOptions } from \"./Mutate\";\nimport { Omit, UseGetProps } from \"./useGet\";\nimport { constructUrl } from \"./util/constructUrl\";\nimport { processResponse } from \"./util/processResponse\";\nimport { useAbort } from \"./useAbort\";\nimport { useDeepCompareCallback, useDeepCompareEffect } from \"./util/useDeepCompareEffect\";\n\nexport interface UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>\n  extends Omit<UseGetProps<TData, TError, TQueryParams, TPathParams>, \"lazy\" | \"debounce\" | \"mock\"> {\n  /**\n   * What HTTP verb are we using?\n   */\n  verb: \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n  /**\n   * Callback called after the mutation is done.\n   *\n   * @param body - Body given to mutate\n   * @param data - Response data\n   */\n  onMutate?: (body: TRequestBody, data: TData) => void;\n  /**\n   * Developer mode\n   * Override the state with some mocks values and avoid to fetch\n   */\n  mock?: {\n    mutate?: MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>;\n    loading?: boolean;\n  };\n  /**\n   * A function to encode body of DELETE requests when appending it\n   * to an existing path\n   */\n  pathInlineBodyEncode?: typeof encodeURIComponent;\n}\n\nexport interface UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams>\n  extends MutateState<TData, TError> {\n  /**\n   * Cancel the current fetch\n   */\n  cancel: () => void;\n  /**\n   * Call the mutate endpoint\n   */\n  mutate: MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>;\n}\n\nexport function useMutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(\n  props: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>,\n): UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams>;\n\nexport function useMutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(\n  verb: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>[\"verb\"],\n  path: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>[\"path\"],\n  props?: Omit<UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>, \"path\" | \"verb\">,\n): UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams>;\n\nexport function useMutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(): UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams> {\n  const props: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams> =\n    typeof arguments[0] === \"object\" ? arguments[0] : { ...arguments[2], path: arguments[1], verb: arguments[0] };\n\n  const context = useContext(Context);\n  const {\n    verb,\n    base = context.base,\n    path,\n    queryParams = EMPTY_OBJECT,\n    resolve = context.resolve,\n    pathParams = EMPTY_OBJECT,\n  } = props;\n  const isDelete = verb === \"DELETE\";\n\n  const [state, setState] = useState<MutateState<TData, TError>>({\n    error: null,\n    loading: false,\n  });\n\n  const { abort, getAbortSignal } = useAbort();\n\n  // Cancel the fetch on unmount\n  useEffect(() => () => abort(), [abort]);\n\n  const { pathInlineBodyEncode, queryParamStringifyOptions, requestOptions, localErrorOnly, onMutate } = props;\n\n  const effectDependencies = [\n    path,\n    pathParams,\n    queryParams,\n    verb,\n    isDelete,\n    base,\n    context,\n    queryParamStringifyOptions,\n    requestOptions,\n    onMutate,\n    abort,\n    pathInlineBodyEncode,\n    localErrorOnly,\n    resolve,\n  ];\n  const mutate = useDeepCompareCallback<MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>>(\n    async (body: TRequestBody, mutateRequestOptions?: MutateRequestOptions<TQueryParams, TPathParams>) => {\n      const signal = getAbortSignal();\n\n      setState(prevState => {\n        if (prevState.error || !prevState.loading) {\n          return { ...prevState, loading: true, error: null };\n        }\n        return prevState;\n      });\n\n      const pathStr =\n        typeof path === \"function\" ? path(mutateRequestOptions?.pathParams || (pathParams as TPathParams)) : path;\n\n      const pathParts = [pathStr];\n\n      const options: RequestInit = {\n        method: verb,\n      };\n\n      // don't set content-type when body is of type FormData\n      if (!(body instanceof FormData)) {\n        options.headers = { \"content-type\": typeof body === \"object\" ? \"application/json\" : \"text/plain\" };\n      }\n\n      if (body instanceof FormData) {\n        options.body = body;\n      } else if (typeof body === \"object\") {\n        options.body = JSON.stringify(body);\n      } else if (isDelete && body !== undefined) {\n        const possiblyEncodedBody = pathInlineBodyEncode ? pathInlineBodyEncode(String(body)) : String(body);\n\n        pathParts.push(possiblyEncodedBody);\n      } else {\n        options.body = (body as unknown) as string;\n      }\n\n      const url = constructUrl(\n        base,\n        pathParts.join(\"/\"),\n        { ...context.queryParams, ...queryParams, ...mutateRequestOptions?.queryParams },\n        {\n          queryParamOptions: { ...context.queryParamStringifyOptions, ...queryParamStringifyOptions },\n        },\n      );\n\n      const propsRequestOptions =\n        (typeof requestOptions === \"function\" ? await requestOptions(url, verb, body) : requestOptions) || {};\n\n      const contextRequestOptions =\n        (typeof context.requestOptions === \"function\"\n          ? await context.requestOptions(url, verb, body)\n          : context.requestOptions) || {};\n\n      const request = new Request(\n        url,\n        merge({}, contextRequestOptions, options, propsRequestOptions, mutateRequestOptions, { signal }),\n      );\n      if (context.onRequest) context.onRequest(request);\n\n      let response: Response;\n      try {\n        response = await fetch(request);\n        if (context.onResponse) context.onResponse(response.clone());\n      } catch (e) {\n        const error = {\n          message: `Failed to fetch: ${e.message}`,\n          data: \"\",\n        };\n\n        setState({\n          error,\n          loading: false,\n        });\n\n        if (!localErrorOnly && context.onError) {\n          context.onError(error, () => mutate(body, mutateRequestOptions));\n        }\n\n        throw error;\n      }\n\n      const { data: rawData, responseError } = await processResponse(response);\n\n      let data: TData | any; // `any` -> data in error case\n      try {\n        data = resolve ? resolve(rawData) : rawData;\n      } catch (e) {\n        // avoid state updates when component has been unmounted\n        // and when fetch/processResponse threw an error\n        if (signal && signal.aborted) {\n          return;\n        }\n\n        const error = {\n          data: e.message,\n          message: `Failed to resolve: ${e.message}`,\n        };\n\n        setState(prevState => ({\n          ...prevState,\n          error,\n          loading: false,\n        }));\n        throw e;\n      }\n\n      if (signal && signal.aborted) {\n        return;\n      }\n\n      if (!response.ok || responseError) {\n        const error = {\n          data,\n          message: `Failed to fetch: ${response.status} ${response.statusText}`,\n          status: response.status,\n        };\n\n        setState(prevState => ({\n          ...prevState,\n          error,\n          loading: false,\n        }));\n\n        if (!localErrorOnly && context.onError) {\n          context.onError(error, () => mutate(body), response);\n        }\n\n        throw error;\n      }\n\n      setState(prevState => ({ ...prevState, loading: false }));\n\n      if (onMutate) {\n        onMutate(body, data);\n      }\n\n      return data;\n    },\n    effectDependencies,\n  );\n  useDeepCompareEffect(() => {\n    if (state.loading) {\n      abort();\n    }\n  }, effectDependencies);\n\n  return {\n    ...state,\n    mutate,\n    ...props.mock,\n    cancel: () => {\n      setState(prevState => ({\n        ...prevState,\n        loading: false,\n      }));\n      abort();\n    },\n  };\n}\n\n// Declaring this in order to have a thing with stable identity\nconst EMPTY_OBJECT = {};\n"],"names":["Context","React","base","parentPath","resolve","data","requestOptions","onError","noop","onRequest","onResponse","queryParams","queryParamStringifyOptions","RestfulReactProvider","render","props","children","value","Provider","RestfulReactConsumer","Consumer","composeUrl","path","composedPath","composePath","startsWith","endsWith","slice","length","url","processResponse","response","status","undefined","responseError","headers","get","includes","json","e","message","text","resolveData","resolvedData","error","resolveError","resolvedDataOrPromise","then","err","JSON","stringify","constructUrl","resolvePathOptions","queryParamOptions","stripTrailingSlash","normalizedBase","trimmedPath","encodedPathWithParams","Object","keys","qs","composed","Boolean","ContextlessGet","AbortController","abortController","signal","loading","lazy","extraOptions","extraHeaders","Headers","options","requestPath","thisRequestOptions","__internal_hasExplicitBase","state","setState","makeRequestPath","concatPath","getRequestOptions","request","Request","fetch","originalResponse","clone","aborted","ok","statusText","localErrorOnly","resolved","debounce","wait","componentDidMount","componentDidUpdate","prevProps","isEqual","toString","componentWillUnmount","abort","refetch","absolutePath","unresolvedData","Get","contextProps","ContextlessPoll","previousData","lastResponse","polling","finished","nextData","equal","keepPolling","until","stop","interval","lastPollIndex","Prefer","isResponseOk","Promise","isModified","prevState","resolvePromise","setTimeout","cycle","Error","start","meta","states","actions","Poll","method","contextRequestOptions","propsRequestOptions","merge","ContextlessMutate","body","mutateRequestOptions","rawData","mutate","onMutate","verb","providerRequestOptions","FormData","has","set","pathInlineBodyEncode","pathWithPossibleBody","Mutate","x","y","isEqualWith","a","b","useDeepCompareMemoize","ref","useRef","current","useDeepCompareEffect","effect","deps","useEffect","useDeepCompareCallback","callback","useCallback","createAbortController","useAbort","instance","getAbortSignal","isCancellable","func","cancel","flush","useGet","arguments","context","useContext","pathParams","useState","pathStr","_fetchData","prev","d","mock","fetchData","useMutate","EMPTY_OBJECT","isDelete","effectDependencies","pathParts","possiblyEncodedBody","String","push","join"],"mappings":"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"}